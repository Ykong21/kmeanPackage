% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/kr_sampling.R
\name{kr_sampling}
\alias{kr_sampling}
\title{KernelReSample: sampling probabilities for each test point}
\usage{
kr_sampling(
  N,
  x,
  y,
  x0s,
  lambda0,
  kernel = c("gaussian", "laplace", "matern"),
  matern_nu = c(0.5, 1.5, 2.5),
  clustering = c("kmeans", "kmeans_pp", "kmeans_rp", "kmedoids"),
  n_centers = 200,
  kmeans_maxiter = 50,
  rp_dim = 24,
  bw_centers_method = c("median", "detcov"),
  bw_scope = c("centers", "train_sample"),
  bw_train_sample = 2000,
  tune_bw = FALSE,
  bw_scales = c(0.25, 0.5, 1, 2),
  joint_tune = FALSE,
  normalize_cols = TRUE,
  return = c("probs", "weights", "both", "prep"),
  verbose = FALSE
)
}
\arguments{
\item{N}{Integer. Number of training points (must equal nrow(x)).}

\item{x}{Matrix. Training covariates (N x p).}

\item{y}{Numeric. Training responses (length N). Used to compute center labels for BIC tuning.}

\item{x0s}{Matrix. Test covariates (m x p).}

\item{lambda0}{Numeric vector. Candidate lambdas for BIC tuning on centers.}

\item{kernel}{Kernel family: "gaussian" (default), "laplace", "matern".}

\item{matern_nu}{Matern smoothness: 0.5, 1.5, or 2.5 (only used if kernel="matern").}

\item{clustering}{Clustering for centers: "kmeans" (default), "kmeans_pp",
"kmeans_rp", or "kmedoids".}

\item{n_centers}{Integer. Number of centers/clusters used for selection weights (default = 200).}

\item{kmeans_maxiter}{Integer. Max iterations for kmeans backends.}

\item{rp_dim}{Integer. Random projection dimension for "kmeans_rp".}

\item{bw_centers_method}{Bandwidth rule for \emph{centers} (selection weights): "median" (default) or "detcov".}

\item{bw_scope}{Scope for centers bandwidth when bw_centers_method is used:
"centers" (default) uses centers; "train_sample" uses a subsample of X.}

\item{bw_train_sample}{Integer. Subsample size if bw_scope="train_sample".}

\item{tune_bw}{Logical. If TRUE, allow bw_scales for centers bandwidth.}

\item{bw_scales}{Numeric. Multiplicative scales applied to centers bandwidth in tuning.}

\item{joint_tune}{Logical. If TRUE and tune_bw=TRUE, joint tune (bw_scale, lambda) by BIC.
If FALSE (default), tune lambda only (bw fixed at base value).}

\item{normalize_cols}{Logical. If TRUE (default), normalize each column of the returned
sampling matrix \code{finalprobs} to sum to 1 (so each column is a valid probability vector).}

\item{return}{Character. What to return:
\itemize{
\item "probs": N x m sampling probabilities (default).
\item "weights": n_centers x m center weights W (normalized by column).
\item "both": both probs and weights.
\item "prep": return a prep object containing centers/idx/A_W/bw/lambda, useful if you want to reuse for new x0s.
}}

\item{verbose}{Logical. Print progress messages.}
}
\value{
A list containing requested outputs and metadata:
\itemize{
\item finalprobs (N x m) if return includes probs
\item W (n_centers x m) if return includes weights
\item idx, centers, lambda_opt, bw_centers, kernel, clustering, etc.
\item timing (elapsed seconds for cluster/ystar/tune/weights/total)
}
}
\description{
Implements ONLY the sampling (selection) part used in \code{kr_boot_plus}:
(1) clustering on training X to get centers,
(2) compute center labels ystar (cluster mean of y),
(3) tune lambda (and optionally bw_scale) on centers by BIC,
(4) for each test point x0: compute center weights and induce train-point probs.
}
\details{
This function does NOT fit any estimator (no KRR / no FALKON). It returns
sampling probabilities (and optionally centers-level weights) that can be
used by any downstream estimator.
}
\examples{
set.seed(1)
N <- 2000
p <- 3
x <- matrix(rnorm(N * p), N, p)
y <- x[, 1] - 2 * x[, 2] + rnorm(N)
m <- 10
x0s <- matrix(rnorm(m * p), m, p)
lambda0 <- 10^seq(-2, 2, length.out = 10)

# 1) Return sampling probabilities (N x m)
samp <- kr_sampling(
  N = N, x = x, y = y, x0s = x0s, lambda0 = lambda0,
  kernel = "gaussian",
  clustering = "kmeans",
  n_centers = 50,
  bw_centers_method = "median",
  normalize_cols = TRUE,
  return = "probs"
)
dim(samp$finalprobs)               # N x m
range(colSums(samp$finalprobs))    # ~ 1

# Draw one bootstrap-resample index set for the first test point
probs1 <- samp$finalprobs[, 1]
idx_sub <- sample.int(N, size = 200, replace = TRUE, prob = probs1)
head(idx_sub)

# 2) Return both probs and center weights
samp2 <- kr_sampling(
  N = N, x = x, y = y, x0s = x0s, lambda0 = lambda0,
  kernel = "laplace",
  clustering = "kmeans_pp",
  n_centers = 50,
  normalize_cols = TRUE,
  return = "both"
)
dim(samp2$W)          # n_centers x m
dim(samp2$finalprobs) # N x m

# 3) Return a prep object (centers/tuning results) for reuse
prep <- kr_sampling(
  N = N, x = x, y = y, x0s = x0s, lambda0 = lambda0,
  n_centers = 50,
  return = "prep"
)
names(prep)

}
